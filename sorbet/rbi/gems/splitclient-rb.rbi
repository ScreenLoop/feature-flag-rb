# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/splitclient-rb/all/splitclient-rb.rbi
#
# splitclient-rb-8.0.0

module SplitIoClient
  def self.load_factory_registry; end
  def self.root; end
  def self.split_factory_registry; end
  def self.split_factory_registry=(arg0); end
end
class SplitIoClient::Constants
end
class SplitIoClient::SplitIoError < StandardError
end
class SplitIoClient::SDKShutdownException < SplitIoClient::SplitIoError
end
class SplitIoClient::SDKBlockerTimeoutExpiredException < SplitIoClient::SplitIoError
end
class SplitIoClient::SSEClientException < SplitIoClient::SplitIoError
  def event; end
  def initialize(event); end
end
class SplitIoClient::ImpressionRouter
  def add_bulk(impressions); end
  def enqueue(impression); end
  def initialize(config); end
  def router_thread; end
end
module SplitIoClient::Cache
end
module SplitIoClient::Cache::Adapters
end
module SplitIoClient::Cache::Adapters::MemoryAdapters
end
class SplitIoClient::Cache::Adapters::MemoryAdapters::MapAdapter
  def add_to_map(key, field, value); end
  def add_to_set(key, values); end
  def bool(key); end
  def clear(_ = nil); end
  def delete(key); end
  def delete_from_map(key, fields); end
  def delete_from_set(key, fields); end
  def empty?; end
  def exists?(key); end
  def find_in_map(key, field); end
  def find_sets_by_prefix(prefix); end
  def find_strings_by_prefix(prefix); end
  def get_all_from_set(key); end
  def get_map(key); end
  def get_set(key); end
  def in_map?(key, field); end
  def in_set?(key, field); end
  def initialize; end
  def initialize_map(key); end
  def initialize_set(key); end
  def map_keys(key); end
  def multiple_strings(keys); end
  def pipelined(&block); end
  def set_bool(key, val); end
  def set_string(key, str); end
  def string(key); end
  def union_sets(set_keys); end
end
class SplitIoClient::Cache::Adapters::MemoryAdapters::QueueAdapter
  def add_to_queue(data); end
  def clear; end
  def empty?; end
  def get_batch(size); end
  def initialize(max_size); end
  def length; end
end
class SplitIoClient::Cache::Adapters::CacheAdapter
  def add(key, value); end
  def add_to_map(key, field, value); end
  def add_to_set(key, values); end
  def clear(namespace_key); end
  def delete(key); end
  def delete_from_set(key, fields); end
  def exists?(key); end
  def find_strings_by_prefix(prefix); end
  def get(key); end
  def get_set(key); end
  def in_set?(key, field); end
  def initialize(config); end
  def initialize_map(key); end
  def initialize_set(*args, &block); end
  def multiple_strings(keys); end
  def pipelined(*args, &block); end
  def set_bool(*args, &block); end
  def set_string(key, value); end
  def string(key); end
  extend Forwardable
end
class SplitIoClient::Cache::Adapters::MemoryAdapter < SimpleDelegator
end
class SplitIoClient::Cache::Adapters::RedisAdapter
  def add_to_map(key, field, value); end
  def add_to_queue(key, val); end
  def add_to_set(key, val); end
  def append_to_string(key, val); end
  def bool(key); end
  def clear(prefix); end
  def delete(key); end
  def delete_from_map(key, field); end
  def delete_from_set(key, val); end
  def exists?(key); end
  def expire(key, seconds); end
  def find_in_map(key, field); end
  def find_sets_by_prefix(prefix); end
  def find_strings_by_pattern(pattern); end
  def find_strings_by_prefix(prefix); end
  def get_all_from_set(key); end
  def get_from_queue(key, count); end
  def get_map(key); end
  def get_set(key); end
  def hincrby(key, field, increment); end
  def in_map?(key, field); end
  def in_set?(key, val); end
  def inc(key, inc = nil); end
  def initialize(redis_url); end
  def initialize_map(key); end
  def initialize_set(key); end
  def map_keys(key); end
  def multiple_strings(keys); end
  def pipelined; end
  def random_set_elements(key, count); end
  def redis; end
  def set_bool(key, val); end
  def set_string(key, str); end
  def string(key); end
  def union_sets(set_keys); end
end
module SplitIoClient::Cache::Fetchers
end
class SplitIoClient::Cache::Fetchers::SegmentFetcher
  def call; end
  def fetch_segment(name, fetch_options = nil); end
  def fetch_segments; end
  def fetch_segments_if_not_exists(names, cache_control_headers = nil); end
  def initialize(segments_repository, api_key, config, telemetry_runtime_producer); end
  def segments_api; end
  def segments_repository; end
  def segments_thread; end
  def stop_segments_thread; end
end
class SplitIoClient::Cache::Fetchers::SplitFetcher
  def add_split_unless_archived(split); end
  def call; end
  def fetch_splits(fetch_options = nil); end
  def initialize(splits_repository, api_key, config, telemetry_runtime_producer); end
  def remove_archived_split(split); end
  def splits_api; end
  def splits_repository; end
  def splits_since(since, fetch_options = nil); end
  def splits_thread; end
  def stop_splits_thread; end
  def store_split(split); end
end
module SplitIoClient::Cache::Filter
end
class SplitIoClient::Cache::Filter::BloomFilter
  def add(string); end
  def best_k(capacity); end
  def best_m(capacity, false_positive_probability); end
  def clear; end
  def contains?(string); end
  def hashes(data); end
  def initialize(capacity, false_positive_probability = nil); end
end
class SplitIoClient::Cache::Filter::FilterAdapter
  def add(feature_name, key); end
  def clear; end
  def contains?(feature_name, key); end
  def initialize(config, filter); end
end
module SplitIoClient::Hashers
end
class SplitIoClient::Hashers::ImpressionHasher
  def initialize; end
  def process(impression); end
  def unknown_if_null(value); end
  def zero_if_null(value); end
end
module SplitIoClient::Observers
end
class SplitIoClient::Observers::ImpressionObserver
  def initialize; end
  def test_and_set(impression); end
end
class SplitIoClient::Observers::NoopImpressionObserver
  def test_and_set(impression); end
end
class SplitIoClient::Cache::Repository
  def initialize(config); end
  def namespace_key(key = nil); end
  def set_string(key, str); end
  def string(key); end
end
module SplitIoClient::Cache::Repositories
end
class SplitIoClient::Cache::Repositories::SegmentsRepository < SplitIoClient::Cache::Repository
  def adapter; end
  def add_keys(name, keys); end
  def add_to_segment(segment); end
  def clear; end
  def get_change_number(name); end
  def get_segment_keys(name); end
  def in_segment?(name, key); end
  def initialize(config); end
  def not_ready!; end
  def ready!; end
  def ready?; end
  def remove_keys(name, keys); end
  def segment_data(name); end
  def segment_keys_count; end
  def segments_count; end
  def set_change_number(name, last_change); end
  def used_segment_names; end
end
class SplitIoClient::Cache::Repositories::SplitsRepository < SplitIoClient::Cache::Repository
  def adapter; end
  def add_split(split); end
  def clear; end
  def decrease_tt_name_count(tt_name); end
  def exists?(name); end
  def get_change_number; end
  def get_split(name); end
  def get_splits(names, symbolize_names = nil); end
  def increase_tt_name_count(tt_name); end
  def initialize(config); end
  def kill(change_number, split_name, default_treatment); end
  def not_ready!; end
  def ready!; end
  def ready?; end
  def remove_split(split); end
  def set_change_number(since); end
  def set_segment_names(names); end
  def split_names; end
  def splits; end
  def splits_count; end
  def traffic_type_exists(tt_name); end
end
class SplitIoClient::Cache::Repositories::EventsRepository < SplitIoClient::Cache::Repository
  def add(*args, &block); end
  def batch(*args, &block); end
  def clear(*args, &block); end
  def event(key, traffic_type, event_type, time, value, properties); end
  def events_api; end
  def initialize(config, api_key, telemetry_runtime_producer); end
  def metadata; end
  def post_events; end
  extend Forwardable
end
class SplitIoClient::Cache::Repositories::ImpressionsRepository < SplitIoClient::Cache::Repository
  def add_bulk(*args, &block); end
  def batch(*args, &block); end
  def clear(*args, &block); end
  def empty?(*args, &block); end
  def initialize(config); end
  extend Forwardable
end
module SplitIoClient::Cache::Repositories::Events
end
class SplitIoClient::Cache::Repositories::Events::MemoryRepository < SplitIoClient::Cache::Repositories::EventsRepository
  def add(key, traffic_type, event_type, time, value, properties, event_size); end
  def batch; end
  def clear; end
  def initialize(config, telemetry_runtime_producer); end
end
class SplitIoClient::Cache::Repositories::Events::RedisRepository < SplitIoClient::Cache::Repositories::EventsRepository
  def add(key, traffic_type, event_type, time, value, properties, size); end
  def batch; end
  def clear; end
  def initialize(config); end
end
module SplitIoClient::Cache::Repositories::Impressions
end
class SplitIoClient::Cache::Repositories::Impressions::MemoryRepository < SplitIoClient::Cache::Repositories::ImpressionsRepository
  def add_bulk(impressions); end
  def batch; end
  def clear; end
  def empty?; end
  def initialize(config); end
  def random_sampler; end
end
class SplitIoClient::Cache::Repositories::Impressions::RedisRepository < SplitIoClient::Cache::Repositories::ImpressionsRepository
  def add_bulk(impressions); end
  def batch; end
  def clear; end
  def get_impressions(number_of_impressions = nil); end
  def initialize(config); end
  def key; end
end
module SplitIoClient::Cache::Senders
end
class SplitIoClient::Cache::Senders::ImpressionsFormatter
  def call(fetch_all_impressions, raw_impressions = nil); end
  def current_impressions(feature_impressions); end
  def feature_impressions(filtered_impressions, feature); end
  def filter_impressions(unfiltered_impressions); end
  def impression_hash(impression); end
  def initialize(impressions_repository); end
  def unique_features(impressions); end
end
class SplitIoClient::Cache::Senders::ImpressionsSender
  def call; end
  def impressions_api; end
  def impressions_thread; end
  def initialize(impressions_repository, config, impressions_api); end
  def post_impressions(fetch_all_impressions = nil); end
end
class SplitIoClient::Cache::Senders::EventsSender
  def call; end
  def events_thread; end
  def initialize(events_repository, config); end
  def post_events; end
end
class SplitIoClient::Cache::Senders::ImpressionsCountSender
  def call; end
  def impressions_count_thread; end
  def initialize(config, impression_counter, impressions_sender_adapter); end
  def post_impressions_count; end
end
class SplitIoClient::Cache::Senders::LocalhostRepoCleaner
  def call; end
  def cleaner_thread; end
  def clear_repositories; end
  def initialize(impressions_repository, events_repository, config); end
end
class SplitIoClient::Cache::Senders::ImpressionsSenderAdapter
  def initialize(config, telemetry_api, impressions_api); end
  def record_impressions_count(*args, &block); end
  def record_uniques_key(*args, &block); end
  extend Forwardable
end
class SplitIoClient::Cache::Senders::MemoryImpressionsSender < SplitIoClient::Cache::Senders::ImpressionsSenderAdapter
  def impressions_count_formatter(counts); end
  def initialize(config, telemetry_api, impressions_api); end
  def record_impressions_count(impressions_count); end
  def record_uniques_key(uniques); end
  def uniques_formatter(uniques); end
end
class SplitIoClient::Cache::Senders::RedisImpressionsSender < SplitIoClient::Cache::Senders::ImpressionsSenderAdapter
  def expire_impressions_count_key(impressions_count, pipeline_result); end
  def impressions_count_key; end
  def initialize(config); end
  def record_impressions_count(impressions_count); end
  def record_uniques_key(uniques); end
  def unique_keys_key; end
  def uniques_formatter(uniques); end
end
module SplitIoClient::Cache::Stores
end
class SplitIoClient::Cache::Stores::LocalhostSplitBuilder
  def self.build_conditions(treatments); end
  def self.build_configurations(treatments); end
  def self.build_partitions(current_treatment_name, treatments); end
  def self.build_rollout_treatment; end
  def self.build_split(feature, treatments); end
  def self.build_splits(splits); end
  def self.build_whitelist_treatment(treatment_name, whitelist_keys); end
end
class SplitIoClient::Cache::Stores::LocalhostSplitStore
  def call; end
  def initialize(splits_repository, config, status_manager = nil); end
  def load_features; end
  def parse_plain_text_features; end
  def parse_yaml_features; end
  def splits_repository; end
  def splits_thread; end
  def store_split(split); end
  def store_splits; end
  def symbolize_feat_keys(yaml_feature); end
end
class SplitIoClient::Cache::Stores::StoreUtils
  def self.random_interval(interval); end
end
class SplitIoClient::SplitClient
  def block_until_ready(time = nil); end
  def destroy; end
  def get_treatment(key, split_name, attributes = nil, split_data = nil, store_impressions = nil, multiple = nil, evaluator = nil); end
  def get_treatment_with_config(key, split_name, attributes = nil, split_data = nil, store_impressions = nil, multiple = nil, evaluator = nil); end
  def get_treatments(key, split_names, attributes = nil); end
  def get_treatments_with_config(key, split_names, attributes = nil); end
  def initialize(api_key, repositories, status_manager, config, impressions_manager, telemetry_evaluation_producer); end
  def keys_from_key(key); end
  def parsed_attributes(attributes); end
  def parsed_treatment(multiple, treatment_data); end
  def ready?; end
  def record_exception(method); end
  def record_latency(method, start); end
  def sanitize_split_names(calling_method, split_names); end
  def track(key, traffic_type_name, event_type, value = nil, properties = nil); end
  def treatment(key, split_name, attributes = nil, split_data = nil, store_impressions = nil, multiple = nil, evaluator = nil, calling_method = nil, impressions = nil); end
  def treatments(key, split_names, attributes = nil, calling_method = nil); end
  def valid_client; end
  def validate_properties(properties); end
  def variable_size(value); end
end
class SplitIoClient::SplitManager
  def block_until_ready(time = nil); end
  def build_split_view(name, split); end
  def initialize(splits_repository = nil, status_manager, config); end
  def ready?; end
  def split(split_name); end
  def split_names; end
  def splits; end
end
module SplitIoClient::Helpers
end
class SplitIoClient::Helpers::ThreadHelper
  def self.alive?(thread_sym, config); end
  def self.stop(thread_sym, config); end
end
class SplitIoClient::SplitFactory
  def adapter; end
  def build_fetchers; end
  def build_impression_counter; end
  def build_impressions_components; end
  def build_impressions_observer; end
  def build_impressions_sender_adapter; end
  def build_repositories; end
  def build_streaming_components; end
  def build_sync_manager; end
  def build_synchronizer; end
  def build_telemetry_components; end
  def build_telemetry_synchronizer; end
  def build_unique_keys_tracker; end
  def client; end
  def config; end
  def initialize(api_key, config_hash = nil); end
  def manager; end
  def register_factory; end
  def repositories; end
  def resume!; end
  def start!; end
  def start_localhost_components; end
  def stop!; end
  def valid_mode; end
  def validate_api_key; end
  include SplitIoClient::Cache::Fetchers
  include SplitIoClient::Cache::Repositories
  include SplitIoClient::Cache::Senders
  include SplitIoClient::Cache::Stores
end
class SplitIoClient::SplitFactoryBuilder
  def self.build(api_key, config = nil); end
end
class SplitIoClient::SplitConfig
  def auth_retry_back_off_base; end
  def auth_retry_back_off_base=(arg0); end
  def auth_service_url; end
  def auth_service_url=(arg0); end
  def base_uri; end
  def base_uri=(arg0); end
  def block_until_ready; end
  def block_until_ready=(arg0); end
  def cache_adapter; end
  def cache_adapter=(arg0); end
  def cache_ttl; end
  def cache_ttl=(arg0); end
  def connection_timeout; end
  def connection_timeout=(arg0); end
  def consumer?; end
  def counter_refresh_rate; end
  def counter_refresh_rate=(arg0); end
  def debug_enabled; end
  def debug_enabled=(arg0); end
  def events_adapter; end
  def events_adapter=(arg0); end
  def events_push_rate; end
  def events_push_rate=(arg0); end
  def events_queue_size; end
  def events_queue_size=(arg0); end
  def events_uri; end
  def events_uri=(arg0); end
  def features_refresh_rate; end
  def features_refresh_rate=(arg0); end
  def impression_listener; end
  def impression_listener=(arg0); end
  def impression_listener_refresh_rate; end
  def impression_listener_refresh_rate=(arg0); end
  def impressions_adapter; end
  def impressions_adapter=(arg0); end
  def impressions_bulk_size; end
  def impressions_bulk_size=(arg0); end
  def impressions_mode; end
  def impressions_mode=(arg0); end
  def impressions_queue_size; end
  def impressions_queue_size=(arg0); end
  def impressions_refresh_rate; end
  def impressions_refresh_rate=(arg0); end
  def init_impressions_mode(impressions_mode, adapter); end
  def initialize(opts = nil); end
  def ip_addresses_enabled; end
  def ip_addresses_enabled=(arg0); end
  def labels_enabled; end
  def labels_enabled=(arg0); end
  def language; end
  def language=(arg0); end
  def localhost_mode; end
  def localhost_mode=(arg0); end
  def log_found_exception(caller, error); end
  def logger; end
  def logger=(arg0); end
  def machine_ip; end
  def machine_ip=(arg0); end
  def machine_name; end
  def machine_name=(arg0); end
  def max_cache_size; end
  def max_cache_size=(arg0); end
  def max_key_size; end
  def max_key_size=(arg0); end
  def mode; end
  def mode=(arg0); end
  def on_demand_fetch_max_retries; end
  def on_demand_fetch_max_retries=(arg0); end
  def on_demand_fetch_retry_delay_seconds; end
  def on_demand_fetch_retry_delay_seconds=(arg0); end
  def read_timeout; end
  def read_timeout=(arg0); end
  def redis_namespace; end
  def redis_namespace=(arg0); end
  def redis_url; end
  def redis_url=(arg0); end
  def sdk_start_time; end
  def sdk_start_time=(arg0); end
  def segments_refresh_rate; end
  def segments_refresh_rate=(arg0); end
  def self.cache_ttl; end
  def self.default; end
  def self.default_auth_retry_back_off_base; end
  def self.default_auth_service_url; end
  def self.default_base_uri; end
  def self.default_block_until_ready; end
  def self.default_cache_adapter; end
  def self.default_connection_timeout; end
  def self.default_counter_refresh_rate(adapter); end
  def self.default_debug; end
  def self.default_events_push_rate; end
  def self.default_events_queue_size; end
  def self.default_events_uri; end
  def self.default_features_refresh_rate; end
  def self.default_impression_listener_refresh_rate; end
  def self.default_impressions_mode; end
  def self.default_impressions_queue_size; end
  def self.default_impressions_refresh_rate; end
  def self.default_impressions_refresh_rate_optimized; end
  def self.default_ip_addresses_enabled; end
  def self.default_labels_logging; end
  def self.default_logger; end
  def self.default_mode; end
  def self.default_offline_refresh_rate; end
  def self.default_on_demand_fetch_max_retries; end
  def self.default_on_demand_fetch_retry_delay_seconds; end
  def self.default_read_timeout; end
  def self.default_redis_namespace; end
  def self.default_redis_url; end
  def self.default_segments_refresh_rate; end
  def self.default_split_file; end
  def self.default_streaming_enabled; end
  def self.default_streaming_reconnect_back_off_base; end
  def self.default_streaming_service_url; end
  def self.default_telemetry_refresh_rate; end
  def self.default_telemetry_service_url; end
  def self.default_unique_keys_bulk_size(adapter); end
  def self.default_unique_keys_cache_max_size; end
  def self.default_unique_keys_refresh_rate(adapter); end
  def self.init_auth_retry_back_off(auth_retry_back_off); end
  def self.init_cache_adapter(adapter, data_structure, queue_size = nil, redis_url = nil); end
  def self.init_impressions_refresh_rate(impressions_mode, refresh_rate, default_rate); end
  def self.init_streaming_reconnect_back_off(streaming_reconnect_back_off); end
  def self.init_telemetry_adapter(adapter, redis_url); end
  def self.init_telemetry_refresh_rate(refresh_rate); end
  def self.machine_hostname(ip_addresses_enabled, machine_name, adapter); end
  def self.machine_ip(ip_addresses_enabled, ip, adapter); end
  def self.map_memory_adapter(name, queue_size); end
  def self.max_cache_size; end
  def self.max_key_size; end
  def self.transport_debug; end
  def split_file; end
  def split_file=(arg0); end
  def split_logger; end
  def split_logger=(arg0); end
  def split_validator; end
  def split_validator=(arg0); end
  def standalone?; end
  def startup_log; end
  def streaming_enabled; end
  def streaming_enabled=(arg0); end
  def streaming_reconnect_back_off_base; end
  def streaming_reconnect_back_off_base=(arg0); end
  def streaming_service_url; end
  def streaming_service_url=(arg0); end
  def telemetry_adapter; end
  def telemetry_adapter=(arg0); end
  def telemetry_refresh_rate; end
  def telemetry_refresh_rate=(arg0); end
  def telemetry_service_url; end
  def telemetry_service_url=(arg0); end
  def threads; end
  def threads=(arg0); end
  def transport_debug_enabled; end
  def transport_debug_enabled=(arg0); end
  def unique_keys_bulk_size; end
  def unique_keys_bulk_size=(arg0); end
  def unique_keys_cache_max_size; end
  def unique_keys_cache_max_size=(arg0); end
  def unique_keys_refresh_rate; end
  def unique_keys_refresh_rate=(arg0); end
  def valid_mode; end
  def valid_mode=(arg0); end
  def version; end
  def version=(arg0); end
end
class SplitIoClient::SplitLogger
  def initialize(config); end
  def log_if_debug(message); end
  def log_if_transport(message); end
end
class SplitIoClient::Validators
  def empty_string?(value); end
  def initialize(config); end
  def log_convert_numeric(key, method, value); end
  def log_empty_string(key, method); end
  def log_invalid_type(key, method); end
  def log_key_too_long(key, method); end
  def log_nil(key, method); end
  def number_or_string?(value); end
  def string?(value); end
  def valid_attributes?(method, attributes); end
  def valid_bucketing_key?(method, key, bucketing_key); end
  def valid_event_type?(event_type); end
  def valid_get_treatment_parameters(method, key, split_name, matching_key, bucketing_key, attributes); end
  def valid_get_treatments_parameters(method, split_names); end
  def valid_key?(method, key); end
  def valid_matcher_arguments(args); end
  def valid_matching_key?(method, matching_key); end
  def valid_properties?(properties); end
  def valid_split_name?(method, split_name); end
  def valid_split_names?(method, split_names); end
  def valid_split_parameters(split_name); end
  def valid_track_key?(key); end
  def valid_track_parameters(key, traffic_type_name, event_type, value, properties); end
  def valid_traffic_type_name?(traffic_type_name); end
  def valid_value?(value); end
end
class SplitIoClient::SplitFactoryRegistry
  def active_factories; end
  def add(api_key); end
  def api_keys_hash; end
  def api_keys_hash=(arg0); end
  def initialize; end
  def number_of_factories_for(api_key); end
  def other_factories; end
  def redundant_active_factories; end
  def remove(api_key); end
end
module SplitIoClient::FaradayMiddleware
end
class SplitIoClient::FaradayMiddleware::Gzip < Faraday::Middleware
  def call(env); end
  def inflate(body); end
  def reset_body(env); end
  def uncompress_gzip(body); end
end
module SplitIoClient::Api
end
class SplitIoClient::Api::Client
  def api_client; end
  def common_headers(api_key); end
  def get_api(url, api_key, params = nil, cache_control_headers = nil); end
  def initialize(config); end
  def post_api(url, api_key, data, headers = nil, params = nil); end
end
class SplitIoClient::Api::Impressions < SplitIoClient::Api::Client
  def impressions_headers; end
  def initialize(api_key, config, telemetry_runtime_producer); end
  def post(impressions); end
  def post_count(impressions_count); end
  def total_impressions(impressions); end
end
class SplitIoClient::Api::Segments < SplitIoClient::Api::Client
  def fetch_segment_changes(name, since, fetch_options = nil); end
  def fetch_segments_by_names(names, fetch_options = nil); end
  def initialize(api_key, segments_repository, config, telemetry_runtime_producer); end
end
class SplitIoClient::Api::Splits < SplitIoClient::Api::Client
  def initialize(api_key, config, telemetry_runtime_producer); end
  def segment_names(split); end
  def since(since, fetch_options = nil); end
  def splits_with_segment_names(splits_json); end
end
class SplitIoClient::Api::Events < SplitIoClient::Api::Client
  def formatted_event(event); end
  def initialize(api_key, config, telemetry_runtime_producer); end
  def post(events); end
end
class SplitIoClient::Api::TelemetryApi < SplitIoClient::Api::Client
  def initialize(config, api_key, telemetry_runtime_producer); end
  def post_telemetry(url, obj, method); end
  def record_init(config_init); end
  def record_stats(stats); end
  def record_unique_keys(uniques); end
end
module SplitIoClient::Engine
end
module SplitIoClient::Engine::Common
end
class SplitIoClient::Engine::Common::ImpressionCounter
  def inc(split_name, time_frame); end
  def initialize; end
  def make_key(split_name, time_frame); end
  def pop_all; end
  def self.truncate_time_frame(timestamp_ms); end
end
class SplitIoClient::Engine::Common::ImpressionManager
  def applied_rule(label); end
  def build_impression(matching_key, bucketing_key, split_name, treatment, params = nil); end
  def impression(impression_data, attributes); end
  def impression_data(matching_key, bucketing_key, split_name, treatment, time = nil); end
  def impression_router; end
  def initialize(config, impressions_repository, impression_counter, telemetry_runtime_producer, impression_observer, unique_keys_tracker); end
  def metadata; end
  def record_stats(stats); end
  def redis?; end
  def should_queue_impression?(impression); end
  def track(impressions); end
  def track_debug_mode(impressions, stats); end
  def track_optimized_mode(impressions, stats); end
end
class SplitIoClient::Engine::Common::NoopImpressionCounter
  def inc(split_name, time_frame); end
  def make_key(split_name, time_frame); end
  def pop_all; end
  def self.truncate_time_frame(timestamp_ms); end
end
class SplitIoClient::Condition < NoMethodError
  def combiner; end
  def create_condition_matcher(matchers); end
  def data; end
  def data=(arg0); end
  def empty?; end
  def initialize(condition, config); end
  def matcher; end
  def matcher_all_keys(_params); end
  def matcher_between(params); end
  def matcher_contains_all_of_set(params); end
  def matcher_contains_any_of_set(params); end
  def matcher_contains_string(params); end
  def matcher_ends_with(params); end
  def matcher_equal_to(params); end
  def matcher_equal_to_boolean(params); end
  def matcher_equal_to_set(params); end
  def matcher_greater_than_or_equal_to(params); end
  def matcher_in_segment(params); end
  def matcher_in_split_treatment(params); end
  def matcher_less_than_or_equal_to(params); end
  def matcher_matches_string(params); end
  def matcher_part_of_set(params); end
  def matcher_starts_with(params); end
  def matcher_whitelist(params); end
  def matchers; end
  def negate; end
  def negation_matcher(matcher); end
  def partitions; end
  def set_partitions; end
  def type; end
end
class SplitIoClient::Partition < NoMethodError
  def data; end
  def data=(arg0); end
  def initialize(partition); end
  def is_empty?; end
  def size; end
  def treatment; end
end
module SplitIoClient::Engine::Parser
end
class SplitIoClient::Engine::Parser::Evaluator
  def call(keys, split, attributes = nil); end
  def initialize(segments_repository, splits_repository, config, multiple = nil); end
  def match(split, keys, attributes); end
  def matcher_instance(type, condition, matcher); end
  def matcher_type(condition); end
  def split_configurations(treatment, split); end
  def treatment_hash(label, treatment, change_number = nil, configurations = nil); end
end
class SplitIoClient::Matcher
  def equals?(obj); end
  def initialize(logger); end
  def string_type?; end
end
class SplitIoClient::Combiners
end
class SplitIoClient::CombiningMatcher < SplitIoClient::Matcher
  def eval_and(args); end
  def initialize(logger, combiner = nil, matchers = nil); end
  def match?(args); end
  def match_with_key?(matcher); end
  def to_s; end
end
class SplitIoClient::AllKeysMatcher < SplitIoClient::Matcher
  def equals?(obj); end
  def match?(_args); end
  def to_s; end
end
class SplitIoClient::NegationMatcher < SplitIoClient::Matcher
  def attribute; end
  def initialize(logger, matcher = nil); end
  def match?(args); end
  def respond_to?(method); end
  def string_type?; end
  def to_s; end
end
class SplitIoClient::UserDefinedSegmentMatcher < SplitIoClient::Matcher
  def initialize(segments_repository, segment_name, logger); end
  def match?(args); end
end
class SplitIoClient::WhitelistMatcher < SplitIoClient::Matcher
  def attribute; end
  def initialize(whitelist_data, logger, validator); end
  def match?(args); end
  def matches_attr_whitelist(args); end
  def matches_user_whitelist(args); end
  def string_type?; end
  def to_s; end
end
class SplitIoClient::EqualToMatcher < SplitIoClient::Matcher
  def attribute; end
  def formatted_value(value, sdk_data = nil); end
  def initialize(attribute_hash, logger, validator); end
  def match?(args); end
end
class SplitIoClient::GreaterThanOrEqualToMatcher < SplitIoClient::Matcher
  def attribute; end
  def formatted_value(value, sdk_data = nil); end
  def initialize(attribute_hash, logger, validator); end
  def match?(args); end
end
class SplitIoClient::LessThanOrEqualToMatcher < SplitIoClient::Matcher
  def attribute; end
  def formatted_value(value, sdk_data = nil); end
  def initialize(attribute_hash, logger, validator); end
  def match?(args); end
end
class SplitIoClient::BetweenMatcher < SplitIoClient::Matcher
  def attribute; end
  def formatted_value(value, sdk_data = nil); end
  def initialize(attribute_hash, logger, validator); end
  def match?(args); end
end
class SplitIoClient::SetMatcher
  def initialize(attribute, remote_array, logger); end
  def local_set(data, attribute); end
  def string_type?; end
end
class SplitIoClient::PartOfSetMatcher < SplitIoClient::SetMatcher
  def attribute; end
  def match?(args); end
end
class SplitIoClient::EqualToSetMatcher < SplitIoClient::SetMatcher
  def attribute; end
  def match?(args); end
end
class SplitIoClient::ContainsAnyMatcher < SplitIoClient::SetMatcher
  def attribute; end
  def match?(args); end
end
class SplitIoClient::ContainsAllMatcher < SplitIoClient::SetMatcher
  def attribute; end
  def match?(args); end
end
class SplitIoClient::StartsWithMatcher
  def attribute; end
  def get_value(args); end
  def initialize(attribute, prefix_list, logger); end
  def match?(args); end
  def string_type?; end
end
class SplitIoClient::EndsWithMatcher
  def attribute; end
  def get_value(args); end
  def initialize(attribute, suffix_list, logger); end
  def match?(args); end
  def string_type?; end
end
class SplitIoClient::ContainsMatcher
  def attribute; end
  def get_value(args); end
  def initialize(attribute, substr_list, logger, validator); end
  def match?(args); end
  def string_type?; end
end
class SplitIoClient::DependencyMatcher
  def initialize(split, treatments, logger); end
  def match?(args); end
  def string_type?; end
end
class SplitIoClient::EqualToBooleanMatcher
  def attribute; end
  def get_value(args); end
  def initialize(attribute, boolean, logger); end
  def match?(args); end
  def string_type?; end
end
class SplitIoClient::MatchesStringMatcher
  def attribute; end
  def initialize(attribute, regexp_string, logger); end
  def match?(args); end
  def string_type?; end
end
class SplitIoClient::Splitter < NoMethodError
  def bucket(hash_value); end
  def count_hash(key, seed, legacy); end
  def get_treatment(id, seed, partitions, legacy_algo); end
  def get_treatment_for_key(bucket, partitions); end
  def hundred_percent_one_treatment?(partitions); end
  def initialize; end
  def legacy_hash(key, seed); end
  def murmur_hash(key, seed); end
  def to_int32(number); end
end
module SplitIoClient::Engine::Impressions
end
class SplitIoClient::Engine::Impressions::NoopUniqueKeysTracker
  def call; end
  def track(feature_name, key); end
end
class SplitIoClient::Engine::Impressions::UniqueKeysTracker
  def add_or_update(feature_name, key); end
  def call; end
  def clear_filter_thread; end
  def initialize(config, filter_adapter, sender_adapter, cache); end
  def send_bulk_data; end
  def send_bulk_data_thread; end
  def track(feature_name, key); end
end
class SplitIoClient::BinarySearchLatencyTracker < NoMethodError
  def self.find_bucket_index(micros); end
  def self.get_bucket(latency); end
end
module SplitIoClient::Engine::Models
end
class SplitIoClient::Engine::Models::Split
  def self.archived?(data); end
  def self.matchable?(data); end
end
class SplitIoClient::Engine::Models::Label
end
class SplitIoClient::Engine::Models::Treatment
end
class SplitIoClient::Engine::AuthApiClient
  def authenticate(api_key); end
  def channels(token_decoded); end
  def control_channels(channels_string); end
  def decode_token(token); end
  def expiration(token_decoded); end
  def initialize(config, telemetry_runtime_producer); end
  def process_error(response); end
  def process_success(response, start); end
end
class SplitIoClient::Engine::BackOff
  def initialize(back_off_base, attempt = nil, max_allowed = nil); end
  def interval; end
  def reset; end
end
class SplitIoClient::Engine::PushManager
  def initialize(config, sse_handler, api_key, telemetry_runtime_producer); end
  def record_telemetry(time); end
  def refresh_token_task(time); end
  def schedule_next_token_refresh(time); end
  def start_sse; end
  def stop_sse; end
end
class SplitIoClient::Engine::StatusManager
  def initialize(config); end
  def ready!; end
  def ready?; end
  def wait_until_ready(seconds = nil); end
end
class SplitIoClient::Engine::SyncManager
  def incoming_push_status_handler; end
  def initialize(config, synchronizer, telemetry_runtime_producer, telemetry_synchronizer, status_manager, sse_handler, push_manager, status_queue); end
  def process_connected; end
  def process_disconnect(reconnect); end
  def process_forced_stop; end
  def process_push_shutdown; end
  def process_subsystem_down; end
  def process_subsystem_ready; end
  def record_telemetry(type, data); end
  def start; end
  def start_consumer; end
  def start_consumer_thread; end
  def start_push_status_monitor; end
  def start_thread; end
end
class SplitIoClient::Engine::Synchronizer
  def attempt_segment_sync(name, target_cn, fetch_options, max_retries, retry_delay_seconds, with_backoff); end
  def attempt_splits_sync(target_cn, fetch_options, max_retries, retry_delay_seconds, with_backoff); end
  def events_sender; end
  def fetch_segment(name, target_change_number); end
  def fetch_splits(target_change_number); end
  def impressions_count_sender; end
  def impressions_sender; end
  def initialize(repositories, config, params); end
  def start_periodic_data_recording; end
  def start_periodic_fetch; end
  def start_telemetry_sync_task; end
  def start_unique_keys_tracker_task; end
  def stop_periodic_fetch; end
  def sync_all(asynchronous = nil); end
  def sync_result(success, remaining_attempts, segment_names = nil); end
  def sync_splits_and_segments; end
  include SplitIoClient::Cache::Fetchers
  include SplitIoClient::Cache::Senders
end
module SplitIoClient::Utilities
  def randomize_interval(interval); end
  def split_bulk_to_send(hash, divisions); end
  def to_epoch(value); end
  def to_epoch_milis(value); end
  def to_milis_zero_out_from_hour(value); end
  def to_milis_zero_out_from_seconds(value); end
  extend SplitIoClient::Utilities
end
module SplitIoClient::SSE
end
module SplitIoClient::SSE::EventSource
end
class SplitIoClient::SSE::EventSource::Client
  def build_request(uri); end
  def close(status = nil); end
  def connect_stream(latch); end
  def connect_thread(latch); end
  def connected?; end
  def dispatch_error(event); end
  def dispatch_event(event); end
  def initialize(config, api_key, telemetry_runtime_producer, event_parser, notification_manager_keeper, notification_processor, status_queue, read_timeout: nil); end
  def process_data(partial_data); end
  def process_event(event); end
  def push_status(status); end
  def read_first_event(data, latch); end
  def socket_connect; end
  def socket_write(latch); end
  def start(url); end
end
class SplitIoClient::SSE::EventSource::EventParser
  def first_event(raw_data); end
  def initialize(config); end
  def parse(raw_event); end
  def parse_event_data(data, type); end
  def read_partial_data(data); end
end
class SplitIoClient::SSE::EventSource::EventTypes
end
class SplitIoClient::SSE::EventSource::StreamData
  def channel; end
  def client_id; end
  def data; end
  def event_type; end
  def initialize(event_type, client_id, data, channel); end
  def occupancy?; end
end
module SplitIoClient::SSE::Workers
end
class SplitIoClient::SSE::Workers::SegmentsWorker
  def add_to_queue(change_number, segment_name); end
  def initialize(synchronizer, config, segments_repository); end
  def perform; end
  def perform_thread; end
  def start; end
  def stop; end
end
class SplitIoClient::SSE::Workers::SplitsWorker
  def add_to_queue(change_number); end
  def initialize(synchronizer, config, splits_repository); end
  def kill_split(change_number, split_name, default_treatment); end
  def perform; end
  def perform_thread; end
  def start; end
  def stop; end
end
class SplitIoClient::SSE::NotificationManagerKeeper
  def are_publishers_available?; end
  def handle_incoming_occupancy_event(event); end
  def initialize(config, telemetry_runtime_producer, status_queue); end
  def process_event_control(type); end
  def process_event_occupancy(channel, publishers); end
  def push_status(status); end
  def update_publishers(channel, publishers); end
end
class SplitIoClient::SSE::NotificationProcessor
  def initialize(config, splits_worker, segments_worker); end
  def process(incoming_notification); end
  def process_segment_update(notification); end
  def process_split_kill(notification); end
  def process_split_update(notification); end
end
class SplitIoClient::SSE::SSEHandler
  def connected?; end
  def initialize(config, splits_worker, segments_worker, sse_client); end
  def sse_client; end
  def start(token_jwt, channels); end
  def start_workers; end
  def stop; end
  def stop_workers; end
end
module SplitIoClient::Telemetry
end
module SplitIoClient::Telemetry::Domain
end
class SplitIoClient::Telemetry::Domain::Constants
end
class SplitIoClient::Telemetry::LastSynchronization < Struct
  def ev; end
  def ev=(_); end
  def ic; end
  def ic=(_); end
  def im; end
  def im=(_); end
  def se; end
  def se=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def sp; end
  def sp=(_); end
  def te; end
  def te=(_); end
  def to; end
  def to=(_); end
end
class SplitIoClient::Telemetry::HttpErrors < Struct
  def ev; end
  def ev=(_); end
  def ic; end
  def ic=(_); end
  def im; end
  def im=(_); end
  def se; end
  def se=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def sp; end
  def sp=(_); end
  def te; end
  def te=(_); end
  def to; end
  def to=(_); end
end
class SplitIoClient::Telemetry::HttpLatencies < Struct
  def ev; end
  def ev=(_); end
  def ic; end
  def ic=(_); end
  def im; end
  def im=(_); end
  def se; end
  def se=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def sp; end
  def sp=(_); end
  def te; end
  def te=(_); end
  def to; end
  def to=(_); end
end
class SplitIoClient::Telemetry::Rates < Struct
  def ev; end
  def ev=(_); end
  def im; end
  def im=(_); end
  def se; end
  def se=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def sp; end
  def sp=(_); end
  def te; end
  def te=(_); end
end
class SplitIoClient::Telemetry::UrlOverrides < Struct
  def a; end
  def a=(_); end
  def e; end
  def e=(_); end
  def s; end
  def s=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def st; end
  def st=(_); end
  def t; end
  def t=(_); end
end
class SplitIoClient::Telemetry::ConfigInit < Struct
  def af; end
  def af=(_); end
  def bt; end
  def bt=(_); end
  def eq; end
  def eq=(_); end
  def hp; end
  def hp=(_); end
  def i; end
  def i=(_); end
  def il; end
  def il=(_); end
  def im; end
  def im=(_); end
  def iq; end
  def iq=(_); end
  def nr; end
  def nr=(_); end
  def om; end
  def om=(_); end
  def rf; end
  def rf=(_); end
  def rr; end
  def rr=(_); end
  def se; end
  def se=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def st; end
  def st=(_); end
  def t; end
  def t=(_); end
  def tr; end
  def tr=(_); end
  def uo; end
  def uo=(_); end
end
class SplitIoClient::Telemetry::Usage < Struct
  def ar; end
  def ar=(_); end
  def ed; end
  def ed=(_); end
  def eq; end
  def eq=(_); end
  def he; end
  def he=(_); end
  def hl; end
  def hl=(_); end
  def ide; end
  def ide=(_); end
  def idr; end
  def idr=(_); end
  def iq; end
  def iq=(_); end
  def ls; end
  def ls=(_); end
  def me; end
  def me=(_); end
  def ml; end
  def ml=(_); end
  def se; end
  def se=(_); end
  def sec; end
  def sec=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def skc; end
  def skc=(_); end
  def sl; end
  def sl=(_); end
  def spc; end
  def spc=(_); end
  def t; end
  def t=(_); end
  def tr; end
  def tr=(_); end
end
class SplitIoClient::Telemetry::ClientMethodLatencies < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def t; end
  def t=(_); end
  def tc; end
  def tc=(_); end
  def tcs; end
  def tcs=(_); end
  def tr; end
  def tr=(_); end
  def ts; end
  def ts=(_); end
end
class SplitIoClient::Telemetry::ClientMethodExceptions < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def t; end
  def t=(_); end
  def tc; end
  def tc=(_); end
  def tcs; end
  def tcs=(_); end
  def tr; end
  def tr=(_); end
  def ts; end
  def ts=(_); end
end
module SplitIoClient::Telemetry::Storages
end
class SplitIoClient::Telemetry::Storages::Memory
  def auth_rejections; end
  def events_data_records; end
  def exceptions; end
  def factory_counters; end
  def http_errors; end
  def http_latencies; end
  def impressions_data_records; end
  def init_auth_rejections; end
  def init_events_data_records; end
  def init_exceptions; end
  def init_factory_counters; end
  def init_http_errors; end
  def init_http_latencies; end
  def init_impressions_data_records; end
  def init_last_synchronization; end
  def init_latencies; end
  def init_session_length; end
  def init_streaming_events; end
  def init_tags; end
  def init_token_refreshes; end
  def initialize; end
  def last_synchronization; end
  def latencies; end
  def session_length; end
  def streaming_events; end
  def tags; end
  def token_refreshes; end
end
class SplitIoClient::Telemetry::EvaluationConsumer
  def initialize(config); end
  def pop_exceptions(*args, &block); end
  def pop_latencies(*args, &block); end
  extend Forwardable
end
class SplitIoClient::Telemetry::EvaluationProducer
  def initialize(config); end
  def record_exception(*args, &block); end
  def record_latency(*args, &block); end
  extend Forwardable
end
class SplitIoClient::Telemetry::InitConsumer
  def bur_timeouts(*args, &block); end
  def initialize(config); end
  def non_ready_usages(*args, &block); end
  extend Forwardable
end
class SplitIoClient::Telemetry::InitProducer
  def initialize(config); end
  def record_bur_timeout(*args, &block); end
  def record_config(*args, &block); end
  def record_non_ready_usages(*args, &block); end
  extend Forwardable
end
class SplitIoClient::Telemetry::RuntimeConsumer
  def events_stats(*args, &block); end
  def impressions_stats(*args, &block); end
  def initialize(config); end
  def last_synchronizations(*args, &block); end
  def pop_auth_rejections(*args, &block); end
  def pop_http_errors(*args, &block); end
  def pop_http_latencies(*args, &block); end
  def pop_streaming_events(*args, &block); end
  def pop_tags(*args, &block); end
  def pop_token_refreshes(*args, &block); end
  def session_length(*args, &block); end
  extend Forwardable
end
class SplitIoClient::Telemetry::RuntimeProducer
  def add_tag(*args, &block); end
  def initialize(config); end
  def record_auth_rejections(*args, &block); end
  def record_events_stats(*args, &block); end
  def record_impressions_stats(*args, &block); end
  def record_session_length(*args, &block); end
  def record_streaming_event(*args, &block); end
  def record_successful_sync(*args, &block); end
  def record_sync_error(*args, &block); end
  def record_sync_latency(*args, &block); end
  def record_token_refreshes(*args, &block); end
  extend Forwardable
end
class SplitIoClient::Telemetry::SyncTask
  def call; end
  def initialize(config, telemetry_synchronizer); end
  def stats_thread; end
  def telemetry_sync_task; end
end
class SplitIoClient::Telemetry::Synchronizer
  def initialize(config, telemtry_consumers, telemetry_init_producer, repositories, telemetry_api); end
  def synchronize_config(*args, &block); end
  def synchronize_stats(*args, &block); end
  extend Forwardable
end
class SplitIoClient::Telemetry::MemoryEvaluationConsumer
  def initialize(config); end
  def pop_exceptions; end
  def pop_latencies; end
end
class SplitIoClient::Telemetry::MemoryEvaluationProducer
  def initialize(config); end
  def record_exception(method); end
  def record_latency(method, bucket); end
end
class SplitIoClient::Telemetry::MemoryInitConsumer
  def bur_timeouts; end
  def find_counts(action); end
  def initialize(config); end
  def non_ready_usages; end
end
class SplitIoClient::Telemetry::MemoryInitProducer
  def find_factory_counters(action); end
  def initialize(config); end
  def record_bur_timeout; end
  def record_config; end
  def record_non_ready_usages; end
end
class SplitIoClient::Telemetry::MemoryRuntimeConsumer
  def events_stats(type); end
  def find_http_errors(type); end
  def find_http_latencies(type); end
  def find_last_synchronization(type); end
  def impressions_stats(type); end
  def initialize(config); end
  def last_synchronizations; end
  def pop_auth_rejections; end
  def pop_http_errors; end
  def pop_http_latencies; end
  def pop_streaming_events; end
  def pop_tags; end
  def pop_token_refreshes; end
  def session_length; end
end
class SplitIoClient::Telemetry::MemoryRuntimeProducer
  def add_tag(tag); end
  def initialize(config); end
  def record_auth_rejections; end
  def record_events_stats(type, count); end
  def record_impressions_stats(type, count); end
  def record_session_length(session); end
  def record_streaming_event(type, data = nil, timestamp = nil); end
  def record_successful_sync(type, value = nil); end
  def record_sync_error(type, status); end
  def record_sync_latency(type, bucket); end
  def record_token_refreshes; end
end
class SplitIoClient::Telemetry::MemorySynchronizer
  def format_stats(usage); end
  def fornat_init_config(init); end
  def http_proxy_detected?; end
  def impressions_mode; end
  def initialize(config, telemtry_consumers, repositories, telemetry_api); end
  def mode; end
  def synchronize_config(active_factories = nil, redundant_active_factories = nil, time_until_ready = nil); end
  def synchronize_stats; end
end
class SplitIoClient::Telemetry::RedisEvaluationProducer
  def exception_key; end
  def initialize(config); end
  def latency_key; end
  def record_exception(method); end
  def record_latency(method, bucket); end
end
class SplitIoClient::Telemetry::RedisInitProducer
  def config_key; end
  def initialize(config); end
  def record_bur_timeout; end
  def record_config(config_data); end
  def record_non_ready_usages; end
end
class SplitIoClient::Telemetry::RedisSynchronizer
  def initialize(config, telemetry_init_producer); end
  def synchronize_config(active_factories = nil, redundant_active_factories = nil, tags = nil); end
  def synchronize_stats; end
end
module Digest
end
class Digest::MurmurHashMRI1 < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def update(str); end
end
class Digest::MurmurHashMRI2 < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def update(str); end
end
class Digest::MurmurHashMRI2A < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def update(str); end
end
class Digest::MurmurHashMRI64A < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def update(str); end
end
class Digest::MurmurHashMRI64B < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def update(str); end
end
class Digest::MurmurHashMRIAligned2 < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def update(str); end
end
class Digest::MurmurHashMRINeutral2 < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def update(str); end
end
class Digest::MurmurHashMRI3_x86_32 < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def finish; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def self.digest(*arg0); end
  def self.rawdigest(*arg0); end
  def update(str); end
end
class Digest::MurmurHashMRI3_x86_128 < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def update(str); end
end
class Digest::MurmurHashMRI3_x64_128 < Digest::Class
  def <<(str); end
  def block_length; end
  def digest_length; end
  def finish; end
  def initialize; end
  def reset; end
  def seed; end
  def seed=(s); end
  def self.digest(*arg0); end
  def self.rawdigest(*arg0); end
  def update(str); end
end
