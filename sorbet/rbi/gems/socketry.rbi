# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/socketry/all/socketry.rbi
#
# socketry-0.5.1

module Socketry
end
class Socketry::Error < StandardError
end
class Socketry::ConnectionRefusedError < Socketry::Error
end
class Socketry::AddressError < Socketry::Error
end
class Socketry::AddressInUseError < Socketry::Error
end
class Socketry::TimeoutError < Socketry::Error
end
class Socketry::StateError < Socketry::Error
end
class Socketry::InternalError < Socketry::Error
end
module Socketry::Resolver
end
class Socketry::Resolver::Error < Socketry::AddressError
end
module Socketry::SSL
end
class Socketry::SSL::Error < Socketry::Error
end
class Socketry::SSL::CertificateVerifyError < Socketry::SSL::Error
end
class Socketry::SSL::HostnameError < Socketry::SSL::CertificateVerifyError
end
class Socketry::Resolver::Resolv
  def close; end
  def initialize(*args); end
  def resolve(hostname, timeout: nil); end
  def self.resolve(hostname, **options); end
end
module Socketry::Resolver::System
  def resolve(hostname, timeout: nil); end
  def self.resolve(hostname, timeout: nil); end
end
module Socketry::Timeout
  def clear_timeout(timeout); end
  def lifetime; end
  def set_timeout(timeout); end
  def start_timer(timer = nil); end
  def time_remaining(timeout); end
end
module Socketry::TCP
end
class Socketry::TCP::Server
  def accept(timeout: nil); end
  def close; end
  def initialize(hostname_or_port, port = nil, read_timeout: nil, write_timeout: nil, timer: nil, resolver: nil, server_class: nil, socket_class: nil); end
  def read_timeout; end
  def resolver; end
  def self.open(hostname_or_port, port = nil, **args); end
  def socket_class; end
  def uptime; end
  def write_timeout; end
  include Socketry::Timeout
end
class Socketry::TCP::Socket
  def addr_fmaily; end
  def close; end
  def closed?; end
  def connect(remote_addr, remote_port, local_addr: nil, local_port: nil, timeout: nil); end
  def ensure_connected; end
  def ensure_disconnected; end
  def from_socket(socket); end
  def initialize(read_timeout: nil, write_timeout: nil, timer: nil, resolver: nil, socket_class: nil); end
  def local_addr; end
  def local_port; end
  def nodelay; end
  def nodelay=(flag); end
  def read(size, outbuf: nil, timeout: nil); end
  def read_nonblock(size, outbuf: nil); end
  def read_timeout; end
  def readpartial(size, outbuf: nil, timeout: nil); end
  def reconnect(timeout: nil); end
  def remote_addr; end
  def remote_port; end
  def resolver; end
  def self.connect(remote_addr, remote_port, **args); end
  def socket_class; end
  def to_io; end
  def write(data, timeout: nil); end
  def write_nonblock(data); end
  def write_timeout; end
  def writepartial(data, timeout: nil); end
  include Socketry::Timeout
end
class Socketry::SSL::Server < Socketry::TCP::Server
  def accept(timeout: nil, **args); end
  def initialize(hostname_or_port, port = nil, ssl_socket_class: nil, ssl_params: nil, **args); end
end
class Socketry::SSL::Socket < Socketry::TCP::Socket
  def accept(tcp_socket, timeout: nil); end
  def close; end
  def connect(remote_addr, remote_port, local_addr: nil, local_port: nil, timeout: nil, enable_sni: nil, verify_hostname: nil); end
  def from_socket(ssl_socket); end
  def initialize(ssl_socket_class: nil, ssl_context: nil, ssl_params: nil, **args); end
  def perform; end
  def read_nonblock(size, outbuf: nil); end
  def write_nonblock(data); end
end
module Socketry::UDP
end
class Socketry::UDP::Datagram
  def addrinfo; end
  def initialize(message, sockaddr); end
  def message; end
  def remote_addr; end
  def remote_host; end
  def remote_port; end
  def sockaddr; end
end
class Socketry::UDP::Socket
  def addr_family; end
  def bind(local_addr, local_port); end
  def close; end
  def closed?; end
  def connect(remote_addr, remote_port); end
  def initialize(addr_family: nil, read_timeout: nil, write_timeout: nil, timer: nil, resolver: nil, socket_class: nil); end
  def read_timeout; end
  def recvfrom(maxlen, timeout: nil); end
  def recvfrom_nonblock(maxlen); end
  def resolver; end
  def self.bind(local_addr, local_port, resolver: nil); end
  def self.connect(remote_addr, remote_port, resolver: nil); end
  def self.from_addr(remote_addr, resolver: nil); end
  def send(msg, host: nil, port: nil); end
  def socket_class; end
  def write_timeout; end
  include Socketry::Timeout
end
