# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(arg); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

module BindingNinja
  METHOD_DEFINER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BitArray
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_31?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_31?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_31?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_31?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_31?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_31?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_31?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_31?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_31?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_31?(); end

  def truffleruby_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_31?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def dependencies_for(groups); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::DepProxy
  def clone(); end
end

class Bundler::DepProxy
  def self.get_proxy(dep, platform); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end

  def github(); end

  def ref(); end
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::Dsl
  def check_primary_source_safety(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_checksum(built_gem_path=T.unsafe(nil)); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def current_branch(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::LazySpecification
  def eql?(other); end

  def platform_string(); end
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::RemoteSpecification
  def required_rubygems_version(); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def results_for(dependency, base); end

  def source_for(name); end
end

class Bundler::Resolver::SpecGroup
  def activated_platforms(); end

  def activated_platforms=(activated_platforms); end

  def sorted_activated_platforms(); end
end

class Bundler::Resolver::SpecGroup
  def self.create_for(specs, all_platforms, specific_platform); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def load_env_plugins(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def glob(); end

  def local?(); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def dependency_api_available?(); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def remote_names(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def missing_specs(); end
end

class Bundler::StubSpecification
  def extensions(); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*arg); end

  def attr_reader(*arg); end

  def attr_writer(*arg); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_error(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *arg); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def are_colors_supported?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*arg); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*arg); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*arg); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

module Byebug
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
end

class Byebug::FullpathSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::WidthSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*arg); end
end

module CodeRay::Encoders
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  extend ::CodeRay::Plugin
  def self.const_missing(sym); end

  def self.file_extension(); end
end

module CodeRay::Encoders
  extend ::CodeRay::PluginHost
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::Plugin
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*arg); end

  def tokens(*arg); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class ConnectionPool
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ConnectionPool::Wrapper
  METHODS = ::T.let(nil, ::T.untyped)
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  VERSION = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

module Diff::LCS
  VERSION = ::T.let(nil, ::T.untyped)
end

Diff::LCS::BalancedCallbacks = Diff::LCS::DefaultCallbacks

class Diff::LCS::Change
  VALID_ACTIONS = ::T.let(nil, ::T.untyped)
end

Diff::LCS::Change::IntClass = Integer

Diff::LCS::SequenceCallbacks = Diff::LCS::DefaultCallbacks

class Digest::MurmurHashMRI1
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Digest::MurmurHashMRI2
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Digest::MurmurHashMRI2A
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Digest::MurmurHashMRI3_x64_128
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Digest::MurmurHashMRI3_x86_128
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Digest::MurmurHashMRI3_x86_32
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Digest::MurmurHashMRI64A
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Digest::MurmurHashMRI64B
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Digest::MurmurHashMRIAligned2
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Digest::MurmurHashMRINeutral2
  DEFAULT_SEED = ::T.let(nil, ::T.untyped)
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.exists?(arg); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*arg); end
end

class Encoding::Converter
  def initialize(*arg); end
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  def sum(*arg); end
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.members(); end
end

module Exception2MessageMapper
  def bind(cl); end
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

module Faraday
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_WITH_BODY = ::T.let(nil, ::T.untyped)
  METHODS_WITH_QUERY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  TIMEOUT_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Excon
  OPTS_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttp
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttpPersistent
  SSL_CONFIGURATIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
  CURL_TIMEOUT_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Rack
  SPECIAL_HEADERS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Test
  def configure(); end

  def initialize(app, stubs=T.unsafe(nil), &block); end

  def stubs(); end

  def stubs=(stubs); end
end

class Faraday::Adapter::Test::Stub
  def headers_match?(request_headers); end

  def matches?(env); end

  def params_match?(env); end

  def path_match?(request_path, meta); end
end

class Faraday::Adapter::Test::Stub
end

class Faraday::Adapter::Test::Stubs
  def delete(path, headers=T.unsafe(nil), &block); end

  def empty?(); end

  def get(path, headers=T.unsafe(nil), &block); end

  def head(path, headers=T.unsafe(nil), &block); end

  def initialize(strict_mode: T.unsafe(nil)); end

  def match(env); end

  def matches?(stack, env); end

  def new_stub(request_method, path, headers=T.unsafe(nil), body=T.unsafe(nil), &block); end

  def options(path, headers=T.unsafe(nil), &block); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def strict_mode=(value); end

  def verify_stubbed_calls(); end
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs
end

class Faraday::Adapter::Test
end

class Faraday::Adapter::Typhoeus
  def call(); end
end

class Faraday::Adapter::Typhoeus
end

Faraday::CompositeReadIO = Faraday::Multipart::CompositeReadIO

class Faraday::Connection
  METHODS = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
end

module Faraday::DecodeMethods
  SUBKEYS_REGEX = ::T.let(nil, ::T.untyped)
end

module Faraday::EmHttp
  VERSION = ::T.let(nil, ::T.untyped)
end

module Faraday::EmSynchrony
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

module Faraday::Excon
  VERSION = ::T.let(nil, ::T.untyped)
end

Faraday::FilePart = UploadIO

module Faraday::HTTPClient
  VERSION = ::T.let(nil, ::T.untyped)
end

module Faraday::Multipart
  VERSION = ::T.let(nil, ::T.untyped)
end

Faraday::Multipart::FilePart = UploadIO

class Faraday::Multipart::Middleware
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

Faraday::Multipart::Parts = Parts

module Faraday::NetHttp
  VERSION = ::T.let(nil, ::T.untyped)
end

module Faraday::NetHttpPersistent
  VERSION = ::T.let(nil, ::T.untyped)
end

Faraday::ParamPart = Faraday::Multipart::ParamPart

Faraday::Parts = Parts

module Faraday::Patron
  VERSION = ::T.let(nil, ::T.untyped)
end

module Faraday::Rack
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder
  LOCK_ERR = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
  REGISTRY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def initialize(app, type, param); end

  def on_request(env); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def self.build_hash(type, hash); end

  def self.header(type, token); end
end

class Faraday::Request::BasicAuthentication
end

class Faraday::Request::BasicAuthentication
  def self.header(login, pass); end
end

class Faraday::Request::Instrumentation
  def initialize(app, options=T.unsafe(nil)); end
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation
end

Faraday::Request::Multipart = Faraday::Multipart::Middleware

Faraday::Request::Retry = Faraday::Retry::Middleware

class Faraday::Request::TokenAuthentication
  def initialize(app, token, options=T.unsafe(nil)); end
end

class Faraday::Request::TokenAuthentication
  def self.header(token, options=T.unsafe(nil)); end
end

class Faraday::Request::UrlEncoded
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::Logger
  def initialize(app, logger=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Faraday::Response::Logger
end

class Faraday::Response::RaiseError
  def response_values(env); end
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
  ServerErrorStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::RaiseError
end

module Faraday::Retry
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Retry::Middleware
  DEFAULT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Retry::Middleware::Options
  DEFAULT_CHECK = ::T.let(nil, ::T.untyped)
end

Faraday::Timer = Timeout

Faraday::UploadIO = UploadIO

module Faraday::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  KeyMap = ::T.let(nil, ::T.untyped)
end

class FeatureFlags::Adapter
  extend ::T::Private::Abstract::Hooks
  extend ::T::InterfaceWrapper::Helpers
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class FeatureFlags::Adapters::SplitIoAdapter::SplitIoAdapterClient
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class FeatureFlags::Client
  extend ::T::Private::Methods::SingletonMethodHooks
  extend ::T::Private::Methods::MethodHooks
end

class FeatureFlags::Config
  extend ::T::Private::Methods::MethodHooks
  extend ::T::Private::Methods::SingletonMethodHooks
end

class FeatureFlags::Credentials
  def self.inherited(s); end
end

class FeatureFlags::Params::AccountRequest
  def self.inherited(s); end
end

module FeatureFlags
  extend ::T::Private::Methods::SingletonMethodHooks
end

class File
  def self.exists?(arg); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*arg); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  def self.redirector(); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

Gem::Installer::ExtensionBuildError = Gem::Ext::BuildError

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Requirement
  include ::Gem::Requirement::CorrectHashForLambdaOperator
end

module Gem::Requirement::CorrectHashForLambdaOperator
  def hash(); end
end

module Gem::Requirement::CorrectHashForLambdaOperator
end

class Gem::Resolver::ActivationRequest
  def others_possible?(); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  include ::Gem::Specification::YamlBackfiller
  def deleted_gem?(); end

  def rg_required_ruby_version=(req); end

  def to_ruby(); end
  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = ::T.let(nil, ::T.untyped)
end

module Gem::Specification::YamlBackfiller
  def to_yaml(opts=T.unsafe(nil)); end
end

module Gem::Specification::YamlBackfiller
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.remove_spec(spec); end
end

class Gem::SpecificationPolicy
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.default_gems_use_full_paths?(); end

  def self.remove_unresolved_default_spec(spec); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
end

class Hash
  def self.ruby2_keywords_hash(hash); end
end

module Hitimes
  INSTANT_CONVERSION_FACTOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hitimes::Stats
  STATS = ::T.let(nil, ::T.untyped)
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def getch(*arg); end

  def getpass(*arg); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(arg); end

  def pressed?(); end

  def raw(*arg); end

  def raw!(*arg); end

  def ready?(); end

  def wait(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end

  def winsize(); end

  def winsize=(winsize); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*arg); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Context
  def __exit__(*arg); end

  def __inspect__(); end

  def __to_s__(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect_last_value(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*arg); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def initialize(file); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::Notifier::AbstractNotifier
  def initialize(prefix, base_notifier); end
end

class IRB::Notifier::LeveledNotifier
  def initialize(base, level, prefix); end
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class JSON::Ext::Generator::State
  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  def self.create_fast_state(); end

  def self.create_pretty_state(); end

  def self.load_file(filespec, opts=T.unsafe(nil)); end

  def self.load_file!(filespec, opts=T.unsafe(nil)); end
end

module JWT::Algos
  ALGOS = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Ecdsa
  NAMED_CURVES = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Eddsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Hmac
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::None
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Ps
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Rsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Unsupported
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

class JWT::ClaimsValidator
  NUMERIC_CLAIMS = ::T.let(nil, ::T.untyped)
end

module JWT::DefaultOptions
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class JWT::Encode
  ALG_KEY = ::T.let(nil, ::T.untyped)
  ALG_NONE = ::T.let(nil, ::T.untyped)
end

class JWT::JWK::EC
  BINARY = ::T.let(nil, ::T.untyped)
  KTY = ::T.let(nil, ::T.untyped)
  KTYS = ::T.let(nil, ::T.untyped)
end

class JWT::JWK::HMAC
  KTY = ::T.let(nil, ::T.untyped)
  KTYS = ::T.let(nil, ::T.untyped)
end

class JWT::JWK::RSA
  BINARY = ::T.let(nil, ::T.untyped)
  KTY = ::T.let(nil, ::T.untyped)
  KTYS = ::T.let(nil, ::T.untyped)
  RSA_KEY_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class JWT::Verify
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

module Kernel
  def pretty_inspect(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module LruRedux
  VERSION = ::T.let(nil, ::T.untyped)
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class NameError
  include ::DidYouMean::Correctable
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTP::Persistent
  DEFAULT_POOL_SIZE = ::T.let(nil, ::T.untyped)
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(arg); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*arg); end

  def self.pbkdf2_hmac(*arg); end

  def self.scrypt(*arg); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(arg); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parser::Context
  FLAGS = ::T.let(nil, ::T.untyped)
end

Parser::CurrentRuby = Parser::Ruby26

class Parser::Diagnostic
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::MaxNumparamStack
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby26
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
  ANONYMOUS_BLOCKARG = ::T.let(nil, ::T.untyped)
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

module ProcToAst
  VERSION = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TEXT_TO_FORMAT = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

class REXML::Parsers::BaseParser
  EXTERNAL_ID_PUBLIC = ::T.let(nil, ::T.untyped)
  EXTERNAL_ID_SYSTEM = ::T.let(nil, ::T.untyped)
  PUBLIC_ID = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
  DEBUG = ::T.let(nil, ::T.untyped)
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Bisect::Channel
  MARSHAL_DUMP_ENCODING = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::ExampleGroup
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterRules
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Hooks::HookCollections
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Pending
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::Configuration
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::BuiltIn::BaseMatcher
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::BePredicate
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Has
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::RaiseError
  UndefinedValue = ::T.let(nil, ::T.untyped)
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

module RSpec::Matchers::DSL::Macros
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::AnyArgMatcher
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::BooleanMatcher
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::NoArgsMatcher
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Parameterized
  VERSION = ::T.let(nil, ::T.untyped)
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::EncodedString
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Random
  def self.bytes(arg); end
end

class Range
  def %(arg); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

class Regexp
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::Quantifier
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
  VAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug
  def comments(*args, &block); end

  def node_ids(); end

  def tokens(*args, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  def compiler(); end

  def initialize(pattern, compiler: T.unsafe(nil)); end

  def node_pattern(); end

  def pattern(); end

  def test(ruby, trace: T.unsafe(nil)); end
  COLOR_SCHEME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def color_map(color_scheme=T.unsafe(nil)); end

  def colorize(color_scheme=T.unsafe(nil)); end

  def colorizer(); end

  def colorizer=(_); end

  def match_map(); end

  def matched?(node); end

  def returned(); end

  def returned=(_); end

  def ruby_ast(); end

  def ruby_ast=(_); end

  def trace(); end

  def trace=(_); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def self.[](*arg); end

  def self.members(); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  def do_compile(); end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  def enter(node_id); end

  def matched?(node_id); end

  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
end

class RuboCop::AST::NodePattern::Compiler::Debug
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  DELTA = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::LexerRex
  CALL = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node
  MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::Repetition
  ARITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser::WithMeta
  def comments(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
  def emit_atom(type, token); end

  def emit_call(type, selector_t, args=T.unsafe(nil)); end

  def emit_list(type, begin_t, children, end_t); end

  def emit_unary_op(type, operator_t=T.unsafe(nil), *children); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
  def initialize(str_or_buffer); end

  def pos(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
end

class RuboCop::AST::NodePattern::Parser::WithMeta
end

module RuboCop::AST::NodePattern::Sets
  MAX = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  SET_0_1 = ::T.let(nil, ::T.untyped)
  SET_10_10 = ::T.let(nil, ::T.untyped)
  SET_1_1 = ::T.let(nil, ::T.untyped)
  SET_1_2 = ::T.let(nil, ::T.untyped)
  SET_ABSTRACT_OVERRIDE_OVERRIDABLE_ETC = ::T.let(nil, ::T.untyped)
  SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  SET_ALL_CONTEXT = ::T.let(nil, ::T.untyped)
  SET_AND_RETURN_AND_RAISE_AND_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_ANY_ALL_NORETURN_ETC = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = ::T.let(nil, ::T.untyped)
  SET_BACKGROUND_SCENARIO_XSCENARIO_ETC = ::T.let(nil, ::T.untyped)
  SET_BEFORE_AFTER = ::T.let(nil, ::T.untyped)
  SET_BE_EQ_EQL_EQUAL = ::T.let(nil, ::T.untyped)
  SET_BE_TRUTHY_BE_FALSEY_BE_FALSY_ETC = ::T.let(nil, ::T.untyped)
  SET_BRANCH_REF_TAG = ::T.let(nil, ::T.untyped)
  SET_CALL_RUN = ::T.let(nil, ::T.untyped)
  SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = ::T.let(nil, ::T.untyped)
  SET_CIPHER_DIGEST = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_INSTANCE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE_STRUCT = ::T.let(nil, ::T.untyped)
  SET_CONSTANTIZE_CONSTANTS_CONST_GET = ::T.let(nil, ::T.untyped)
  SET_CONTEXT_SHARED_CONTEXT = ::T.let(nil, ::T.untyped)
  SET_COUNT_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = ::T.let(nil, ::T.untyped)
  SET_DESCRIBE_FEATURE = ::T.let(nil, ::T.untyped)
  SET_DOUBLE_SPY = ::T.let(nil, ::T.untyped)
  SET_EACH_EXAMPLE = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_INDEX_WITH_INDEX = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_OBJECT_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  SET_ENUMERATOR_RATIONAL_COMPLEX_THREAD = ::T.let(nil, ::T.untyped)
  SET_EQL_EQ_BE = ::T.let(nil, ::T.untyped)
  SET_ESCAPE_ENCODE_UNESCAPE_DECODE = ::T.let(nil, ::T.untyped)
  SET_EXACTLY_AT_LEAST_AT_MOST = ::T.let(nil, ::T.untyped)
  SET_EXPECT_ALLOW = ::T.let(nil, ::T.untyped)
  SET_FACTORYGIRL_FACTORYBOT = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST__ETC = ::T.let(nil, ::T.untyped)
  SET_FIXNUM_BIGNUM = ::T.let(nil, ::T.untyped)
  SET_FORMAT_SPRINTF_PRINTF = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_EXTEND_PREPEND = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = ::T.let(nil, ::T.untyped)
  SET_IS_EXPECTED_SHOULD_SHOULD_NOT = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES = ::T.let(nil, ::T.untyped)
  SET_KEY_HAS_KEY_FETCH_ETC = ::T.let(nil, ::T.untyped)
  SET_LAST_FIRST = ::T.let(nil, ::T.untyped)
  SET_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_LOAD_RESTORE = ::T.let(nil, ::T.untyped)
  SET_MAP_COLLECT = ::T.let(nil, ::T.untyped)
  SET_NEW_ = ::T.let(nil, ::T.untyped)
  SET_NEW_OPEN = ::T.let(nil, ::T.untyped)
  SET_NIL_ = ::T.let(nil, ::T.untyped)
  SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PUBLIC = ::T.let(nil, ::T.untyped)
  SET_PROC_LAMBDA = ::T.let(nil, ::T.untyped)
  SET_PROP_CONST = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_ERROR_RAISE_EXCEPTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_RECEIVE_HAVE_RECEIVED = ::T.let(nil, ::T.untyped)
  SET_RECEIVE_MESSAGE_CHAIN_STUB_CHAIN = ::T.let(nil, ::T.untyped)
  SET_RECEIVE_RECEIVE_MESSAGES_RECEIVE_MESSAGE_CHAIN_HAVE_RECEIVED = ::T.let(nil, ::T.untyped)
  SET_RECEIVE_RECEIVE_MESSAGE_CHAIN = ::T.let(nil, ::T.untyped)
  SET_REDUCE_INJECT = ::T.let(nil, ::T.untyped)
  SET_REJECT_REJECT = ::T.let(nil, ::T.untyped)
  SET_REQUIRE_REQUIRE_RELATIVE = ::T.let(nil, ::T.untyped)
  SET_SELECT_SELECT = ::T.let(nil, ::T.untyped)
  SET_SEND_PUBLIC_SEND___SEND__ = ::T.let(nil, ::T.untyped)
  SET_SHOULD_SHOULD_NOT = ::T.let(nil, ::T.untyped)
  SET_SKIP_PENDING = ::T.let(nil, ::T.untyped)
  SET_SORT_BY_SORT = ::T.let(nil, ::T.untyped)
  SET_SPAWN_SYSTEM = ::T.let(nil, ::T.untyped)
  SET_SPRINTF_FORMAT = ::T.let(nil, ::T.untyped)
  SET_STRUCT_CLASS = ::T.let(nil, ::T.untyped)
  SET_SUCC_PRED_NEXT = ::T.let(nil, ::T.untyped)
  SET_TEMPFILE_STRINGIO = ::T.let(nil, ::T.untyped)
  SET_TO_ENUM_ENUM_FOR = ::T.let(nil, ::T.untyped)
  SET_TO_H_TO_HASH = ::T.let(nil, ::T.untyped)
  SET_TO_I_TO_F_TO_C_TO_R = ::T.let(nil, ::T.untyped)
  SET_TRUE_FALSE = ::T.let(nil, ::T.untyped)
  SET_TYPE_TEMPLATE_TYPE_MEMBER = ::T.let(nil, ::T.untyped)
  SET_ZERO_POSITIVE_NEGATIVE = ::T.let(nil, ::T.untyped)
  SET__ = ::T.let(nil, ::T.untyped)
  SET__AT_SLICE = ::T.let(nil, ::T.untyped)
  SET__EQUAL_EQL = ::T.let(nil, ::T.untyped)
  SET__GLOB = ::T.let(nil, ::T.untyped)
  SET___ = ::T.let(nil, ::T.untyped)
  SET___2 = ::T.let(nil, ::T.untyped)
  SET___3 = ::T.let(nil, ::T.untyped)
  SET___4 = ::T.let(nil, ::T.untyped)
  SET___5 = ::T.let(nil, ::T.untyped)
  SET___6 = ::T.let(nil, ::T.untyped)
  SET___7 = ::T.let(nil, ::T.untyped)
  SET___EQL = ::T.let(nil, ::T.untyped)
  SET___METHOD_____CALLEE__ = ::T.let(nil, ::T.untyped)
  SET____ = ::T.let(nil, ::T.untyped)
  SET____ETC = ::T.let(nil, ::T.untyped)
  SET____ETC_2 = ::T.let(nil, ::T.untyped)
  SET____ETC_3 = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::RuboCopCompatibility
  INCOMPATIBLE_COPS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
  TYPE_TO_METHOD = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI
  DEFAULT_PARALLEL_OPTIONS = ::T.let(nil, ::T.untyped)
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
  YAML_OPTIONAL_DOC_START = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::ExecuteRunner
  INTEGRATION_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::SuggestExtensions
  INCLUDED_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
end

class RuboCop::ConfigObsoletion
  COP_RULE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_RULES_FILE = ::T.let(nil, ::T.untyped)
  PARAMETER_RULE_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedParameter
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::RemovedCop
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigRegeneration
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  COMMAND_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::AllowedIdentifiers
  SIGILS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
  CHECKED_OPTIONS_CONFIG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemFilename
  GEMFILE_FILES = ::T.let(nil, ::T.untyped)
  GEMS_RB_FILES = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_REQUIRED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemVersion
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  REQUIRED_MSG = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFICATION_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  MSG = ::T.let(nil, ::T.untyped)
  MSG_HTTP_PROTOCOL = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CodeLength
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
  FORMATS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Corrector
  NOOP_CONSUMER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  CORRECTION = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DateAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequireMFA
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::HashShorthandSyntax
  EXPLICIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
  OMIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::HashTransformMethod
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::IfThenCorrector
  DEFAULT_INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BeginEndAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  KIND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
  TYPE_MSG = ::T.let(nil, ::T.untyped)
  WIDTH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
  PARENT_TYPES_FOR_INDENTED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ParameterAlignment
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RedundantLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SingleLineBlockChain
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  MSG = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBrackets
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousAssignment
  MISTAKES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence
  MSG = ::T.let(nil, ::T.untyped)
  PRECEDENCE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRange
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  ALLOWED_MATH_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  CLASS_METHOD_DELIMETER = ::T.let(nil, ::T.untyped)
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  INSTANCE_METHOD_DELIMETER = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedConstants
  DO_NOT_USE_MSG = ::T.let(nil, ::T.untyped)
  SUGGEST_GOOD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  MSG = ::T.let(nil, ::T.untyped)
  NO_ARG_ALGORITHM = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateBranch
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  MSG_REPEATED_ELEMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyClass
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  METACLASS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInPattern
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INVALID = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IdentityComparison
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SET_OPERATION_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
  CONVERSION_METHODS = ::T.let(nil, ::T.untyped)
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberedParameterAssignment
  LVAR_MSG = ::T.let(nil, ::T.untyped)
  NUMBERED_PARAMETER_RANGE = ::T.let(nil, ::T.untyped)
  NUM_PARAM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrAssignmentToConstant
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  COP_NAME = ::T.let(nil, ::T.untyped)
  DEPARTMENT_MARKER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantDirGlobSort
  GLOB_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  MSG = ::T.let(nil, ::T.untyped)
  NIL_SPECIFIC_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireRelativeSelfPath
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SEND_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SymbolConversion
  MSG = ::T.let(nil, ::T.untyped)
  MSG_CONSISTENCY = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToEnumArguments
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TripleQuotes
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
  CONTINUE_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  METHOD_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  URI_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessRuby2Keywords
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessTimes
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
  MSG = ::T.let(nil, ::T.untyped)
  OPTIONAL_PARAMETERS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  VAR_SETTER_TO_GETTER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Migration::DepartmentName
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  EXCLUDED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BlockForwarding
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::InclusiveLanguage
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_FILE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  DYNAMIC_DEFINE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::PreferredDelimiters
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::AlignLeftLetBrace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::AlignRightLetBrace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::AnyInstance
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::AroundBlock
  MSG_NO_ARG = ::T.let(nil, ::T.untyped)
  MSG_UNUSED_ARG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Be
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::BeEql
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::BeforeAfterAll
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Capybara::FeatureMethods
  MAP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Capybara::VisibilityMatcher
  CAPYBARA_MATCHER_METHODS = ::T.let(nil, ::T.untyped)
  MSG_FALSE = ::T.let(nil, ::T.untyped)
  MSG_TRUE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ContextMethod
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ContextWording
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribeClass
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribeMethod
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribeSymbol
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribedClass
  DESCRIBED_CLASS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::DescribedClassModuleWrapping
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Dialect
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyExampleGroup
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyHook
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterExample
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterExampleGroup
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterFinalLet
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterHook
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::EmptyLineAfterSubject
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExampleLength
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExampleWithoutDescription
  MSG_ADD_DESCRIPTION = ::T.let(nil, ::T.untyped)
  MSG_DEFAULT_ARGUMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExampleWording
  IT_PREFIX = ::T.let(nil, ::T.untyped)
  MSG_IT = ::T.let(nil, ::T.untyped)
  MSG_SHOULD = ::T.let(nil, ::T.untyped)
  SHOULD_PREFIX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExpectActual
  COMPLEX_LITERALS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_LITERALS = ::T.let(nil, ::T.untyped)
  SUPPORTED_MATCHERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExpectChange
  MSG_BLOCK = ::T.let(nil, ::T.untyped)
  MSG_CALL = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExpectInHook
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ExpectOutput
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RSpec::ExplicitHelper
  BUILT_IN_MATCHERS = ::T.let(nil, ::T.untyped)
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::FactoryBot::AttributeDefinedStatically
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::FactoryBot::CreateList
  MSG_CREATE_LIST = ::T.let(nil, ::T.untyped)
  MSG_N_TIMES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::FactoryBot::FactoryClassName
  ALLOWED_CONSTANTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::FilePath
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Focus
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::HookArgument
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  IMPLICIT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::HooksBeforeExamples
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::IdenticalEqualityAssertion
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ImplicitBlockExpectation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ImplicitExpect
  ENFORCED_REPLACEMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ImplicitSubject
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RSpec::InflectedHelper
  MSG_INFLECTED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::InstanceSpy
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::InstanceVariable
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ItBehavesLike
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::IteratedExpectation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::LeadingSubject
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::LeakyConstantDeclaration
  MSG_CLASS = ::T.let(nil, ::T.untyped)
  MSG_CONST = ::T.let(nil, ::T.untyped)
  MSG_MODULE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::LetBeforeExamples
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::LetSetup
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MessageChain
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MessageExpectation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SUPPORTED_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MessageSpies
  MSG_HAVE_RECEIVED = ::T.let(nil, ::T.untyped)
  MSG_RECEIVE = ::T.let(nil, ::T.untyped)
  SUPPORTED_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MissingExampleGroupArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MultipleDescribes
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MultipleExpectations
  ANYTHING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MultipleMemoizedHelpers
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::MultipleSubjects
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::NamedSubject
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::NestedGroups
  DEPRECATED_MAX_KEY = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::NotToNot
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::OverwritingSetup
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Pending
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Rails::AvoidSetupHook
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ReceiveCounts
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ReceiveNever
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::RepeatedDescription
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::RepeatedExample
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::RepeatedExampleGroupBody
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::RepeatedExampleGroupDescription
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::RepeatedIncludeExample
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ReturnFromStub
  MSG_AND_RETURN = ::T.let(nil, ::T.untyped)
  MSG_BLOCK = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ReturnFromStub::BlockBodyCorrector
  NULL_BLOCK_BODY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ScatteredLet
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::ScatteredSetup
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SharedContext
  MSG_CONTEXT = ::T.let(nil, ::T.untyped)
  MSG_EXAMPLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SharedExamples::Checker
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SingleArgumentMessageChain
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::StubbedMock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::SubjectStub
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::UnspecifiedException
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RSpec::Variable::Helpers
end

module RuboCop::Cop::RSpec::Variable::Helpers
  def self.all(element); end
end

module RuboCop::Cop::RSpec::Variable::Subjects
end

module RuboCop::Cop::RSpec::Variable::Subjects
  def self.all(element); end
end

class RuboCop::Cop::RSpec::VariableDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::VariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::VerifiedDoubles
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::VoidExpect
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::RSpec::Yield
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::IoMethods
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::CallbackConditionalsBinding
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::EnforceSigilOrder
  CODING_REGEX = ::T.let(nil, ::T.untyped)
  FROZEN_REGEX = ::T.let(nil, ::T.untyped)
  INDENT_REGEX = ::T.let(nil, ::T.untyped)
  MAGIC_REGEX = ::T.let(nil, ::T.untyped)
  PREFERRED_ORDER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidExtendTSigHelpersInShims
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidIncludeConstLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidRBIOutsideOfSorbetDir
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidSuperclassConstLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidUntypedStructProps
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::OneAncestorPerLine
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::SignatureBuildOrder
  ORDER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::SingleLineRbiClassModuleDefinitions
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ValidSigil
  SIGIL_REGEX = ::T.let(nil, ::T.untyped)
  STRICTNESS_LEVELS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  ACCESSOR_METHODS = ::T.let(nil, ::T.untyped)
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayCoercion
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::CaseEquality
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassEqualityComparison
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionCompact
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG_COLON_STYLE = ::T.let(nil, ::T.untyped)
  MSG_SPACE_STYLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
  BLOCK_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndlessMethod
  CORRECTION_STYLES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EVAL = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_FILE = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileRead
  MSG = ::T.let(nil, ::T.untyped)
  READ_FILE_START_TO_FINISH_MODES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileWrite
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TRUNCATING_WRITE_MODES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashConversion
  MSG_LITERAL_HASH_ARG = ::T.let(nil, ::T.untyped)
  MSG_LITERAL_MULTI_ARG = ::T.let(nil, ::T.untyped)
  MSG_SPLAT = ::T.let(nil, ::T.untyped)
  MSG_TO_H = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashExcept
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::IfInsideElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithBooleanLiteralBranches
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_ELSIF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
  MSG_IF_ELSE = ::T.let(nil, ::T.untyped)
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InPatternThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LambdaCall
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapToHash
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineInPatternThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedFileDirname
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilLambda
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NonNilCheck
  MSG_FOR_REDUNDANCY = ::T.let(nil, ::T.untyped)
  MSG_FOR_REPLACEMENT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParameters
  MSG_DISALLOW = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParametersLimit
  DEFAULT_MAX_VALUE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OpenStructUse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
  MESSAGE_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::QuotedSymbols
  MSG_DOUBLE = ::T.let(nil, ::T.untyped)
  MSG_SINGLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  MSG_REDUNDANT_CHARACTER_CLASS = ::T.let(nil, ::T.untyped)
  REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  ALLOWED_ALWAYS_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  MSG_REDUNDANT_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignmentBranch
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelectByRegexp
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_METHODS = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
  MSG = ::T.let(nil, ::T.untyped)
  NOT_SUPPORTED_ENDLESS_METHOD_BODY_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SlicingWithRange
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  LIBRARY_NAME = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StaticClass
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringChars
  BAD_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SwapValues
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::TernaryParentheses
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TopLevelMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessLogicalOperators
  FORBID_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
  FORBID_MIXED_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VisibilityHelp
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::DirectiveComment
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  DIRECTIVE_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  REDUNDANT_DIRECTIVE_COP = ::T.let(nil, ::T.untyped)
  REDUNDANT_DIRECTIVE_COP_DEPARTMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::GitHubActionsFormatter
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::PacmanFormatter
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment
  KEYWORDS = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
  FORMAT = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
end

RuboCop::NodePattern::Builder = RuboCop::AST::NodePattern::Builder

class RuboCop::AST::NodePattern::Compiler
end

RuboCop::NodePattern::Compiler::Debug = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler
end

class RuboCop::AST::NodePattern::Lexer
end

RuboCop::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern
end

class RuboCop::Options
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

module RuboCop::RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Sorbet
  CONFIG = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetFinder
  HIDDEN_PATH_SUBSTRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::GemspecFile
  GEMSPEC_EXTENSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
  RUBY_VERSION_FILENAME = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::ToolVersionsFile
  TOOL_VERSIONS_FILENAME = ::T.let(nil, ::T.untyped)
  TOOL_VERSIONS_PATTERN = ::T.let(nil, ::T.untyped)
end

RuboCop::Token = RuboCop::AST::Token

module RuboCop::Version
  CANONICAL_FEATURE_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*arg); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(arg); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Socketry
  VERSION = ::T.let(nil, ::T.untyped)
end

Socketry::Resolver::DEFAULT_RESOLVER = Socketry::Resolver::System

module Socketry::Timeout
  DEFAULT_TIMEOUTS = ::T.let(nil, ::T.untyped)
end

Socketry::Timeout::DEFAULT_TIMER = Hitimes::Interval

module SorbetStructComparable
  VERSION = ::T.let(nil, ::T.untyped)
end

module SplitIoClient
  EVENTS_SIZE_THRESHOLD = ::T.let(nil, ::T.untyped)
  EVENT_AVERAGE_SIZE = ::T.let(nil, ::T.untyped)
  GET_TREATMENT = ::T.let(nil, ::T.untyped)
  GET_TREATMENTS = ::T.let(nil, ::T.untyped)
  GET_TREATMENTS_WITH_CONFIG = ::T.let(nil, ::T.untyped)
  GET_TREATMENT_WITH_CONFIG = ::T.let(nil, ::T.untyped)
  TRACK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::AllKeysMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Api::Client
  RUBY_ENCODING = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::BetweenMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::BinarySearchLatencyTracker
  BUCKETS = ::T.let(nil, ::T.untyped)
  MAX_LATENCY = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Cache::Adapters::RedisAdapter
  SCAN_SLICE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Cache::Repositories::Events::MemoryRepository
  EVENTS_MAX_SIZE_BYTES = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Cache::Repositories::Impressions::RedisRepository
  EXPIRE_SECONDS = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Cache::Repositories::SegmentsRepository
  KEYS_SLICE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Cache::Senders::RedisImpressionsSender
  EXPIRE_SECONDS = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Combiners
  AND = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::CombiningMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Condition
  TYPE_ROLLOUT = ::T.let(nil, ::T.untyped)
  TYPE_WHITELIST = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Constants
  CONTROL_PRI = ::T.let(nil, ::T.untyped)
  CONTROL_SEC = ::T.let(nil, ::T.untyped)
  EXPIRATION_RATE = ::T.let(nil, ::T.untyped)
  FETCH_BACK_OFF_BASE_RETRIES = ::T.let(nil, ::T.untyped)
  OCCUPANCY_CHANNEL_PREFIX = ::T.let(nil, ::T.untyped)
  PUSH_CONNECTED = ::T.let(nil, ::T.untyped)
  PUSH_FORCED_STOP = ::T.let(nil, ::T.untyped)
  PUSH_NONRETRYABLE_ERROR = ::T.let(nil, ::T.untyped)
  PUSH_RETRYABLE_ERROR = ::T.let(nil, ::T.untyped)
  PUSH_SUBSYSTEM_DOWN = ::T.let(nil, ::T.untyped)
  PUSH_SUBSYSTEM_OFF = ::T.let(nil, ::T.untyped)
  PUSH_SUBSYSTEM_READY = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::ContainsAllMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::ContainsAnyMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::ContainsMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::DependencyMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::EndsWithMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

module SplitIoClient::Engine
  BACKOFF_MAX_ALLOWED = ::T.let(nil, ::T.untyped)
end

module SplitIoClient::Engine::Common
  TIME_INTERVAL_MS = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Engine::Common::ImpressionCounter
  DEFAULT_AMOUNT = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Engine::Impressions::UniqueKeysTracker
  INTERVAL_TO_CLEAR_LONG_TERM_CACHE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Engine::Models::Label
  ARCHIVED = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  KILLED = ::T.let(nil, ::T.untyped)
  NOT_FOUND = ::T.let(nil, ::T.untyped)
  NOT_IN_SPLIT = ::T.let(nil, ::T.untyped)
  NOT_READY = ::T.let(nil, ::T.untyped)
  NO_RULE_MATCHED = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Engine::Models::Treatment
  CONTROL = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Engine::SyncManager
  SYNC_MODE_POLLING = ::T.let(nil, ::T.untyped)
  SYNC_MODE_STREAMING = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Engine::Synchronizer
  ON_DEMAND_FETCH_BACKOFF_BASE_SECONDS = ::T.let(nil, ::T.untyped)
  ON_DEMAND_FETCH_BACKOFF_MAX_RETRIES = ::T.let(nil, ::T.untyped)
  ON_DEMAND_FETCH_BACKOFF_MAX_WAIT_SECONDS = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::EqualToBooleanMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::EqualToMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::EqualToSetMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::FaradayMiddleware::Gzip
  ACCEPT_ENCODING = ::T.let(nil, ::T.untyped)
  CONTENT_ENCODING = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  RUBY_ENCODING = ::T.let(nil, ::T.untyped)
  SUPPORTED_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::GreaterThanOrEqualToMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::LessThanOrEqualToMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::MatchesStringMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::NegationMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Observers::ImpressionObserver
  LAST_SEEN_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::PartOfSetMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::SSE::EventSource::Client
  CONNECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  DEFAULT_READ_TIMEOUT = ::T.let(nil, ::T.untyped)
  ERROR_EVENT_TYPE = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE_RESPONSE = ::T.let(nil, ::T.untyped)
  OK_CODE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::SSE::EventSource::EventParser
  BAD_REQUEST_CODE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::SSE::EventSource::EventTypes
  CONTROL = ::T.let(nil, ::T.untyped)
  SEGMENT_UPDATE = ::T.let(nil, ::T.untyped)
  SPLIT_KILL = ::T.let(nil, ::T.untyped)
  SPLIT_UPDATE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::SSE::NotificationManagerKeeper
  DISABLED = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  PAUSED = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::SplitFactory
  LOCALHOST_API_KEY = ::T.let(nil, ::T.untyped)
  ROOT_PROCESS_ID = ::T.let(nil, ::T.untyped)
  SINGLETON_WARN = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::StartsWithMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Telemetry::Domain::Constants
  ABLY_ERROR = ::T.let(nil, ::T.untyped)
  BUR_TIMEOUT = ::T.let(nil, ::T.untyped)
  CONNECTION_ERROR = ::T.let(nil, ::T.untyped)
  EVENTS_DROPPED = ::T.let(nil, ::T.untyped)
  EVENTS_QUEUED = ::T.let(nil, ::T.untyped)
  EVENT_SYNC = ::T.let(nil, ::T.untyped)
  IMPRESSIONS_DEDUPE = ::T.let(nil, ::T.untyped)
  IMPRESSIONS_DROPPED = ::T.let(nil, ::T.untyped)
  IMPRESSIONS_QUEUED = ::T.let(nil, ::T.untyped)
  IMPRESSIONS_SYNC = ::T.let(nil, ::T.untyped)
  IMPRESSION_COUNT_SYNC = ::T.let(nil, ::T.untyped)
  NON_READY_USAGES = ::T.let(nil, ::T.untyped)
  OCCUPANCY_PRI = ::T.let(nil, ::T.untyped)
  OCCUPANCY_SEC = ::T.let(nil, ::T.untyped)
  SEGMENT_SYNC = ::T.let(nil, ::T.untyped)
  SPLIT_SYNC = ::T.let(nil, ::T.untyped)
  SSE_CONNECTION_ESTABLISHED = ::T.let(nil, ::T.untyped)
  STREAMING_STATUS = ::T.let(nil, ::T.untyped)
  SYNC_MODE = ::T.let(nil, ::T.untyped)
  TELEMETRY_SYNC = ::T.let(nil, ::T.untyped)
  TOKEN_REFRESH = ::T.let(nil, ::T.untyped)
  TOKEN_SYNC = ::T.let(nil, ::T.untyped)
  TRACK = ::T.let(nil, ::T.untyped)
  TREATMENT = ::T.let(nil, ::T.untyped)
  TREATMENTS = ::T.let(nil, ::T.untyped)
  TREATMENTS_WITH_CONFIG = ::T.let(nil, ::T.untyped)
  TREATMENT_WITH_CONFIG = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Telemetry::MemoryInitConsumer
  DEFAULT_VALUE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::Telemetry::MemoryRuntimeConsumer
  DEFAULT_VALUE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::UserDefinedSegmentMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class SplitIoClient::WhitelistMatcher
  MATCHER_TYPE = ::T.let(nil, ::T.untyped)
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def shellescape(); end

  def shellsplit(); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringScanner
  def bol?(); end

  def initialize(*arg); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def filter(*arg); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class TracePoint
  def __enable(arg, arg1); end

  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

class Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Unparser::AST
  ASSIGN_NODES = ::T.let(nil, ::T.untyped)
  CLOSE_NODES = ::T.let(nil, ::T.untyped)
  FIRST_CHILD = ::T.let(nil, ::T.untyped)
  INHERIT_NODES = ::T.let(nil, ::T.untyped)
  RESET_NODES = ::T.let(nil, ::T.untyped)
  TAUTOLOGY = ::T.let(nil, ::T.untyped)
end

class Unparser::AST::Enumerator
  include ::Enumerable
  include ::Unparser::Equalizer::Methods
end

class Unparser::AST::LocalVariableScope
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
end

class Unparser::Buffer
  INDENT_SPACE = ::T.let(nil, ::T.untyped)
  NL = ::T.let(nil, ::T.untyped)
end

class Unparser::Color
  include ::Unparser::Equalizer::Methods
  GREEN = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
end

class Unparser::Concord
  MAX_NR_OF_OBJECTS = ::T.let(nil, ::T.untyped)
end

module Unparser::Constants
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  K_ALIAS = ::T.let(nil, ::T.untyped)
  K_AND = ::T.let(nil, ::T.untyped)
  K_BEGIN = ::T.let(nil, ::T.untyped)
  K_BREAK = ::T.let(nil, ::T.untyped)
  K_CASE = ::T.let(nil, ::T.untyped)
  K_CLASS = ::T.let(nil, ::T.untyped)
  K_DEF = ::T.let(nil, ::T.untyped)
  K_DEFINE = ::T.let(nil, ::T.untyped)
  K_DEFINED = ::T.let(nil, ::T.untyped)
  K_DO = ::T.let(nil, ::T.untyped)
  K_EEND = ::T.let(nil, ::T.untyped)
  K_ELSE = ::T.let(nil, ::T.untyped)
  K_ELSIF = ::T.let(nil, ::T.untyped)
  K_ENCODING = ::T.let(nil, ::T.untyped)
  K_END = ::T.let(nil, ::T.untyped)
  K_ENSURE = ::T.let(nil, ::T.untyped)
  K_FALSE = ::T.let(nil, ::T.untyped)
  K_FILE = ::T.let(nil, ::T.untyped)
  K_FOR = ::T.let(nil, ::T.untyped)
  K_IF = ::T.let(nil, ::T.untyped)
  K_IN = ::T.let(nil, ::T.untyped)
  K_MODULE = ::T.let(nil, ::T.untyped)
  K_NEXT = ::T.let(nil, ::T.untyped)
  K_NIL = ::T.let(nil, ::T.untyped)
  K_NOT = ::T.let(nil, ::T.untyped)
  K_OR = ::T.let(nil, ::T.untyped)
  K_POSTEXE = ::T.let(nil, ::T.untyped)
  K_PREEXE = ::T.let(nil, ::T.untyped)
  K_REDO = ::T.let(nil, ::T.untyped)
  K_RESCUE = ::T.let(nil, ::T.untyped)
  K_RETRY = ::T.let(nil, ::T.untyped)
  K_RETURN = ::T.let(nil, ::T.untyped)
  K_SELF = ::T.let(nil, ::T.untyped)
  K_SUPER = ::T.let(nil, ::T.untyped)
  K_THEN = ::T.let(nil, ::T.untyped)
  K_TRUE = ::T.let(nil, ::T.untyped)
  K_UNDEF = ::T.let(nil, ::T.untyped)
  K_UNLESS = ::T.let(nil, ::T.untyped)
  K_UNTIL = ::T.let(nil, ::T.untyped)
  K_WHEN = ::T.let(nil, ::T.untyped)
  K_WHILE = ::T.let(nil, ::T.untyped)
  K_YIELD = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
end

class Unparser::Diff
  include ::Unparser::Equalizer::Methods
  ADDITION = ::T.let(nil, ::T.untyped)
  DELETION = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
end

class Unparser::Either
  include ::Unparser::RequireBlock
  include ::Unparser::Equalizer::Methods
end

class Unparser::Emitter
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Constants
  include ::Unparser::AbstractType
  NO_INDENT = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Assignment
  BINARY_OPERATOR = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::BinaryAssign
  MAP = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::CaseGuard
  MAP = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::FlipFlop
  MAP = ::T.let(nil, ::T.untyped)
  SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Float
  INFINITY = ::T.let(nil, ::T.untyped)
  NEG_INFINITY = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Hookexe
  MAP = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Morearg
  MAP = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::NthRef
  PREFIX = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Post
  MAP = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Primitive::Complex
  MAP = ::T.let(nil, ::T.untyped)
  RATIONAL_FORMAT = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Primitive::Rational
  RATIONAL_FORMAT = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Procarg
  PARENS = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Range
  SYMBOLS = ::T.let(nil, ::T.untyped)
  TOKENS = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Repetition
  MAP = ::T.let(nil, ::T.untyped)
end

class Unparser::Emitter::Simple
  MAP = ::T.let(nil, ::T.untyped)
end

module Unparser::NodeDetails
  include ::Unparser::NodeHelpers
end

class Unparser::NodeDetails::Send
  include ::Unparser::NodeHelpers
  include ::Unparser::Equalizer::Methods
end

module Unparser::Writer
  include ::Unparser::NodeHelpers
end

class Unparser::Writer::Binary
  include ::Unparser::Adamantium
  include ::Unparser::NodeHelpers
end

class Unparser::Writer::DynamicString
  include ::Unparser::Adamantium
  include ::Unparser::NodeHelpers
end

class Unparser::Writer::Resbody
  include ::Unparser::NodeHelpers
end

class Unparser::Writer::Rescue
  include ::Unparser::Adamantium
  include ::Unparser::NodeHelpers
end

class Unparser::Writer::Send
  include ::Unparser::Constants
  include ::Unparser::Adamantium
  include ::Unparser::NodeHelpers
end

module Warning
  extend ::Warning
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::Inflate
  def initialize(*arg); end
end
